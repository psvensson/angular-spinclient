// Generated by CoffeeScript 1.9.1
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  angular.module('ngSpinclient', ['uuid4', 'ngMaterial']).factory('spinclient', function(uuid4, $q, $rootScope) {
    var service;
    service = {
      subscribers: [],
      objsubscribers: [],
      objectsSubscribedTo: [],
      outstandingMessages: [],
      modelcache: [],
      rightscache: [],
      io: null,
      sessionId: null,
      objects: [],
      failureMessage: void 0,
      failed: function(msg) {
        return console.log('spinclient message failed!! ' + msg);
      },
      setSessionId: function(id) {
        if (id) {
          console.log('++++++++++++++++++++++++++++++++++++++ spinclient setting session id to ' + id);
          return service.sessionId = id;
        }
      },
      dumpOutstanding: function() {},
      setWebSocketInstance: (function(_this) {
        return function(io) {
          service.io = io;
          return service.io.on('message', function(reply) {
            var detail, i, index, info, message, status, subscribers;
            status = reply.status;
            message = reply.payload;
            info = reply.info;
            service.dumpOutstanding();
            index = -1;
            if (reply.messageId) {
              i = 0;
              while (i < service.outstandingMessages.length) {
                detail = service.outstandingMessages[i];
                if (detail.messageId === reply.messageId) {
                  if (reply.status === 'FAILURE') {
                    console.log('spinclient message FAILURE');
                    console.dir(reply);
                    service.failuremessage = reply.info;
                    service.infomessage = '';
                    detail.d.reject(reply);
                    break;
                  } else {
                    service.infomessage = reply.info;
                    service.failuremessage = '';
                    detail.d.resolve(message);
                    index = i;
                    break;
                  }
                }
                i++;
              }
              if (index > -1) {
                return service.outstandingMessages.splice(index, 1);
              }
            } else {
              subscribers = service.subscribers[info];
              if (subscribers) {
                return subscribers.forEach(function(listener) {
                  return listener(message);
                });
              } else {
                console.log('no subscribers for message ' + message);
                return console.dir(reply);
              }
            }
          });
        };
      })(this),
      registerListener: function(detail) {
        var subscribers;
        console.log('spinclient::registerListener called for ' + detail.message);
        subscribers = service.subscribers[detail.message] || [];
        subscribers.push(detail.callback);
        return service.subscribers[detail.message] = subscribers;
      },
      registerObjectSubscriber: function(detail) {
        var d, localsubs, sid;
        d = $q.defer();
        sid = uuid4.generate();
        localsubs = service.objectsSubscribedTo[detail.id];
        if (!localsubs) {
          localsubs = [];
          service._registerObjectSubscriber({
            id: detail.id,
            type: detail.type,
            cb: function(updatedobj) {
              var k, lsubs, results1, v;
              lsubs = service.objectsSubscribedTo[detail.id];
              results1 = [];
              for (k in lsubs) {
                v = lsubs[k];
                if (v.cb) {
                  results1.push(v.cb(updatedobj));
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            }
          }).then(function(remotesid) {
            localsubs['remotesid'] = remotesid;
            localsubs[sid] = detail;
            service.objectsSubscribedTo[detail.id] = localsubs;
            return d.resolve(sid);
          });
        }
        return d.promise;
      },
      _registerObjectSubscriber: function(detail) {
        var d, subscribers;
        d = $q.defer();
        subscribers = service.objsubscribers[detail.id] || [];
        service.emitMessage({
          target: 'registerForUpdatesOn',
          obj: {
            id: detail.id,
            type: detail.type
          }
        }).then(function(reply) {
          subscribers[reply] = detail.cb;
          service.objsubscribers[detail.id] = subscribers;
          return d.resolve(reply);
        }, function(reply) {
          return service.failed(reply);
        });
        return d.promise;
      },
      deRegisterObjectSubscriber: (function(_this) {
        return function(sid, o) {
          var count, j, k, len, localsubs, v;
          localsubs = service.objectsSubscribedTo[o.id] || [];
          if (localsubs[sid]) {
            console.log('deregistering local updates for object ' + o.id);
            delete localsubs[sid];
            count = 0;
            for (v = j = 0, len = localsubs.length; j < len; v = ++j) {
              k = localsubs[v];
              count++;
            }
            if (count === 1) {
              return service._deRegisterObjectSubscriber('remotesid', o);
            }
          }
        };
      })(this),
      _deRegisterObjectSubscriber: (function(_this) {
        return function(sid, o) {
          var subscribers;
          subscribers = service.objsubscribers[o.id] || [];
          if (subscribers && subscribers[sid]) {
            delete subscribers[sid];
            service.objsubscribers[o.id] = subscribers;
            return service.emitMessage({
              target: 'deRegisterForUpdatesOn',
              id: o.id,
              type: o.type,
              listenerid: sid
            }).then(function(reply) {
              return console.log('deregistering server updates for object ' + o.id);
            });
          }
        };
      })(this),
      emitMessage: function(detail) {
        var d, e;
        d = $q.defer();
        try {
          detail.messageId = uuid4.generate();
          detail.sessionId = service.sessionId;
          detail.d = d;
          service.outstandingMessages.push(detail);
          service.io.emit('message', JSON.stringify(detail));
        } catch (_error) {
          e = _error;
          console.log('spinclient emitMessage ERROR: ' + e);
        }
        return d.promise;
      },
      getModelFor: function(type) {
        var d;
        d = $q.defer();
        if (service.modelcache[type]) {
          d.resolve(service.modelcache[type]);
        } else {
          service.emitMessage({
            target: 'getModelFor',
            modelname: type
          }).then(function(model) {
            service.modelcache[type] = model;
            return d.resolve(model);
          });
        }
        return d.promise;
      },
      getRightsFor: function(type) {
        var d;
        d = $q.defer();
        if (service.rightscache[type]) {
          d.resolve(service.rightscache[type]);
        } else {
          service.emitMessage({
            target: 'getAccessTypesFor',
            modelname: type
          }).then(function(rights) {
            service.rightscache[type] = rights;
            return d.resolve(rights);
          });
        }
        return d.promise;
      },
      listTargets: function() {
        var d;
        d = $q.defer();
        service.emitMessage({
          target: 'listcommands'
        }).then(function(targets) {
          return d.resolve(targets);
        });
        return d.promise;
      },
      flattenModel: function(model) {
        var k, rv, v;
        rv = {};
        for (k in model) {
          v = model[k];
          if (angular.isArray(v)) {
            rv[k] = v.map(function(e) {
              return e.id;
            });
          } else {
            rv[k] = v;
          }
        }
        return rv;
      }
    };
    service.subscribers['OBJECT_UPDATE'] = [
      function(obj) {
        var k, o, prop, results1, subscribers, v, val;
        subscribers = service.objsubscribers[obj.id] || [];
        results1 = [];
        for (k in subscribers) {
          v = subscribers[k];
          if (!service.objects[obj.id]) {
            service.objects[obj.id] = obj;
          } else {
            o = service.objects[obj.id];
            for (prop in obj) {
              val = obj[prop];
              o[prop] = val;
            }
          }
          results1.push(v(obj));
        }
        return results1;
      }
    ];
    return service;
  }).directive('alltargets', [
    'spinclient', function(client) {
      return {
        restrict: 'AE',
        replace: true,
        template: '<div> <h2>Status: {{status}}</h2> Return Type:<md-select ng-model="currentmodeltype" placeholder="Select a return type for calls"> <md-option ng-value="opt" ng-repeat="opt in modeltypes">{{ opt }}</md-option> </md-select> <div layout="row"> <div flex> <div ng-repeat="target in targets"> <button ng-click="callTarget(target)">{{target.name}}</button> - <span ng-if="target.args==\'<none>\'">{{target.args}}</span><span ng-if="target.args!=\'<none>\'"><input type="text" ng-model="target.args"></span> </div> </div> <div flex> <spinlist ng-if="results && results.length > 0" list="results" listmodel="currentmodeltype" edit="\'true\'" onselect="onitemselect" style="height:300px;overflow:auto"></spinlist> <md-divider></md-divider> <div ng-if="itemselected"> <spinwalker model="itemselected" edit="\'true\'"></spinwalker> </div> </div> </div> </div>',
        link: function(scope, elem, attrs) {},
        controller: function($scope) {
          var failure, success;
          $scope.results = [];
          console.log('alltargets controller');
          $scope.onitemselect = (function(_this) {
            return function(item) {
              console.log('alltargets item selected ' + item.name);
              return $scope.itemselected = item;
            };
          })(this);
          client.listTargets().then(function(_targets) {
            var k, results1, v;
            $scope.targets = [];
            results1 = [];
            for (k in _targets) {
              v = _targets[k];
              results1.push($scope.targets.push({
                name: k,
                argnames: v,
                args: v
              }));
            }
            return results1;
          });
          success = function(results) {
            $scope.results = results;
            return console.dir($scope.results);
          };
          failure = function(reply) {
            console.log('failure' + reply);
            return $scope.status = reply.status + ' - ' + reply.info;
          };
          $scope.callTarget = function(t) {
            var callobj, i, values;
            $scope.status = "";
            console.log('calltarget called with ' + t.name);
            callobj = {
              target: t.name
            };
            if (t.argnames !== "<none>") {
              values = t.args.split(',');
              i = 0;
              t.argnames.split(',').forEach(function(arg) {
                return callobj[arg] = values[i++];
              });
            }
            return client.emitMessage(callobj).then(success, failure);
          };
          return client.emitMessage({
            target: 'listTypes'
          }).then(function(types) {
            return $scope.modeltypes = types;
          });
        }
      };
    }
  ]).directive('spinmodel', [
    'spinclient', '$mdDialog', function(client, $mdDialog) {
      return {
        restrict: 'AE',
        replace: true,
        template: '<div style="padding:15px"> <md-subheader class="md-no-sticky" style="background-color:#ddd"> <md-icon md-svg-src="assets/images/ic_folder_shared_24px.svg" ></md-icon> {{model.type}} {{objects[model.id].name}} </md-subheader> <md-list flex> <md-list-item ng-repeat="prop in listprops" flex layout="row"  layout-fill> <md-input-container layout-padding layout-fill style="min-height:20px"> <label flex="25"> {{prop.name}} </label> <span flex ng-if="prop.type && prop.value && !prop.hashtable && !prop.array"> <md-button ng-click="enterDirectReference(prop)">{{prop.name}}</md-button> > </span> <input flex="50" ng-if="!isdate(prop.name) && !prop.array && !prop.type && isEditable(prop.name) && prop.name != \'id\'" type="text" ng-model="prop.value" ng-change="onChange(model, prop.name, prop.value)"> <input flex="50" ng-if="!isdate(prop.name) && !prop.array && !prop.type && !isEditable(prop.name) || prop.name == \'id\'" type="text" ng-model="prop.value" disabled="true"> <input flex="50" ng-if="isdate(prop.name)" type="datetime" value="{{prop.value}}" ng-disabled="true"> <spinlist ng-if="isEditable(prop.name) && prop.array" flex search="local" listmodel="prop.type" edit="edit" list="model[prop.name]" onselect="onselect" ondelete="ondelete" replace="true"></spinlist> <spinlist ng-if="!isEditable(prop.name) && prop.array" flex  listmodel="prop.type" list="model[prop.name]" onselect="onselect" replace="true"></spinlist> <spinhash ng-if="prop.hashtable" flex  listmodel="prop.type" list="prop.value" onselect="onselect" replace="true"></spinhash> <div layout-align="right" ng-if="accessrights[prop.type].create && (prop.array || prop.hashtable)"><md-button class="md-raised" ng-click="addModel(prop.type, prop.name)">New {{prop.type}}</md-button></div> <div layout-align="right" ng-if="accessrights[model.type].write && (prop.array || prop.hashtable)"><md-button class="md-raised" ng-click="selectModel(prop.type, prop.name)">Add {{prop.type}}</md-button></div> </md-input-container> </md-list-item> </md-list> </div>',
        scope: {
          model: '=model',
          edit: '=?edit',
          onselect: '&',
          hideproperties: '=?hideproperties'
        },
        link: function(scope) {
          return scope.onselect = scope.onselect();
        },
        controller: function($scope) {
          var failure, success;
          $scope.hideproperties = $scope.hideproperties || [];
          $scope.isarray = angular.isArray;
          $scope.subscription = void 0;
          $scope.nonEditable = ['createdAt', 'createdBy', 'modifiedAt'];
          $scope.activeField = void 0;
          $scope.objects = client.objects;
          $scope.accessrights = [];
          $scope.local = 'local';
          $scope.isdate = function(name) {
            return name.indexOf('At') > -1;
          };
          $scope.onSubscribedObject = function(o) {
            var k, results1, v;
            console.log('==== spinmodel onSubscribedModel called for ' + o.id + ' updating model..');
            results1 = [];
            for (k in o) {
              v = o[k];
              results1.push($scope.model[k] = o[k]);
            }
            return results1;
          };
          $scope.isEditable = (function(_this) {
            return function(propname) {
              var rv;
              rv = $scope.edit;
              if (indexOf.call($scope.nonEditable, propname) >= 0) {
                rv = false;
              }
              return rv;
            };
          })(this);
          $scope.$watch('model', function(newval, oldval) {
            console.log('spinmodel watch fired for ' + newval);
            if ($scope.model) {
              client.getRightsFor($scope.model.type).then(function(rights) {
                return $scope.accessrights[$scope.model.type] = rights;
              });
              if ($scope.listprops && newval.id === oldval.id) {
                $scope.updateModel();
              } else {
                $scope.renderModel();
              }
              if (!$scope.subscription) {
                return client.registerObjectSubscriber({
                  id: $scope.model.id,
                  type: $scope.model.type,
                  cb: $scope.onSubscribedObject
                }).then(function(listenerid) {
                  return $scope.subscription = {
                    sid: listenerid,
                    o: $scope.model
                  };
                });
              }
            }
          });
          success = (function(_this) {
            return function(result) {
              return console.log('success: ' + result);
            };
          })(this);
          failure = (function(_this) {
            return function(err) {
              return console.log('error: ' + err);
            };
          })(this);
          $scope.onChange = (function(_this) {
            return function(model, prop, val) {
              console.log('spinmodel onChange called for');
              model[prop] = val;
              console.dir(model);
              $scope.activeField = model.type;
              return client.emitMessage({
                target: 'updateObject',
                obj: model
              }).then(success, failure);
            };
          })(this);
          $scope.ondelete = function(item) {
            console.log('model delete for list item');
            return client.getModelFor($scope.model.type).then(function(md) {
              var i, j, len, list, mid, propname;
              propname = null;
              md.forEach(function(m) {
                if (m.type === item.type) {
                  return propname = m.name;
                }
              });
              list = $scope.model[propname];
              for (i = j = 0, len = list.length; j < len; i = ++j) {
                mid = list[i];
                if (mid === item.id) {
                  list.splice(i, 1);
                }
              }
              console.log('updating parent model to list with spliced list');
              return client.emitMessage({
                target: 'updateObject',
                obj: $scope.model
              }).then(function() {
                return console.log('update done');
              }, failure);
            });
          };
          $scope.updateModel = function() {
            var k, ref, results1, v;
            ref = $scope.model;
            results1 = [];
            for (k in ref) {
              v = ref[k];
              results1.push($scope.listprops.forEach(function(lp) {
                console.log('model.updateModel run for ' + lp);
                if (lp.type) {
                  client.getRightsFor(lp.type).then(function(rights) {
                    return $scope.accessrights[lp.type] = rights;
                  });
                }
                if (lp.name === k) {
                  return lp.value = v;
                }
              }));
            }
            return results1;
          };
          $scope.renderModel = (function(_this) {
            return function() {
              $scope.listprops = [];
              return client.getModelFor($scope.model.type).then(function(md) {
                var foo, i, j, len, modeldef, notshow, prop, ref, results1, val;
                modeldef = {};
                md.forEach(function(modelprop) {
                  return modeldef[modelprop.name] = modelprop;
                });
                if ($scope.model) {
                  $scope.listprops.push({
                    name: 'id',
                    value: $scope.model.id
                  });
                  results1 = [];
                  for (i = j = 0, len = md.length; j < len; i = ++j) {
                    prop = md[i];
                    if (prop.type) {
                      client.getRightsFor(prop.type).then(function(rights) {
                        return $scope.accessrights[prop.type] = rights;
                      });
                    }
                    notshow = (ref = prop.name, indexOf.call($scope.hideproperties, ref) >= 0);
                    if (prop.name !== 'id' && !notshow && prop.name !== $scope.activeField) {
                      if (prop.name.indexOf('At') > -1) {
                        val = new Date($scope.model[prop.name]).toString();
                      } else if (typeof $scope.model[prop.name] === 'object') {
                        val = JSON.stringify($scope.model[prop.name]);
                      } else {
                        val = $scope.model[prop.name];
                      }
                      foo = {
                        name: prop.name,
                        value: val || "",
                        type: modeldef[prop.name].type,
                        array: modeldef[prop.name].array,
                        hashtable: modeldef[prop.name].hashtable
                      };
                      results1.push($scope.listprops.push(foo));
                    } else {
                      results1.push(void 0);
                    }
                  }
                  return results1;
                }
              });
            };
          })(this);
          $scope.enterDirectReference = (function(_this) {
            return function(prop) {
              console.log('enterDirectReference called for ');
              console.dir(prop);
              return client.emitMessage({
                target: '_get' + prop.type,
                obj: {
                  id: $scope.model[prop.name],
                  type: prop.type
                }
              }).then(function(o) {
                console.log('enterDirectReference got back ');
                console.dir(o);
                return $scope.onselect(o);
              }, failure);
            };
          })(this);
          $scope.addModel = function(type, propname) {
            console.log('addModel called for type ' + type);
            return client.emitMessage({
              target: '_create' + type,
              obj: {
                name: 'new ' + type,
                type: type
              }
            }).then((function(_this) {
              return function(o) {
                $scope.model[propname].push(o.id);
                console.log('parent model is now');
                console.dir($scope.model);
                return client.emitMessage({
                  target: 'updateObject',
                  obj: $scope.model
                }).then(success, failure);
              };
            })(this), failure);
          };
          $scope.selectModel = function(type, propname) {
            return client.emitMessage({
              target: '_list' + type + 's'
            }).then(function(objlist) {
              return $mdDialog.show({
                controller: function(scope) {
                  var list;
                  console.log('++++++++++++++ selectModel controller type=' + type + ', propname=' + propname + ' objlist is...');
                  console.dir(objlist);
                  list = [];
                  objlist.forEach(function(obj) {
                    return list.push(obj.id);
                  });
                  scope.list = list;
                  scope.type = type;
                  console.log('list is');
                  console.dir(list);
                  scope.onlistmodeldelete = function() {
                    return console.log('onlistmodeldelete called. Ignoring this since we\'re in the middle of selecting');
                  };
                  return scope.onselect = function(model) {
                    console.log('* selectModel onselect callback');
                    console.dir(model);
                    $scope.model[propname].push(model.id);
                    client.emitMessage({
                      target: 'updateObject',
                      obj: $scope.model
                    }).then(success, failure);
                    return $mdDialog.hide();
                  };
                },
                template: '<md-dialog aria-label="selectdialog"><md-dialog.content style="width:300px;margin:10px;overflow:auto"><spinlist listmodel="type" list="list" onselect="onselect" ondelete="onlistmodeldelete" search="\'local\'"></spinlist></md-dialog.content></md-dialog>'
              });
            });
          };
          return $scope.$on('$destroy', (function(_this) {
            return function() {
              var s;
              s = $scope.subscription;
              console.log('spinmodel captured $destroy event s = ' + s);
              if (s) {
                return client.deRegisterObjectSubscriber(s.sid, s.o);
              }
            };
          })(this));
        }
      };
    }
  ]).directive('spinwalker', [
    'spinclient', function(client) {
      return {
        restrict: 'AE',
        replace: true,
        template: '<div> <span ng-repeat="crumb in breadcrumbs"> <md-button ng-click="crumbClicked(crumb)">{{crumbPresentation(crumb)}}</md-button> > </span> <md-divider></md-divider> <spinmodel model="selectedmodel" edit="edit" onselect="onselect" ondelete="ondelete" hideproperties="hideproperties" style="height:600px;overflow:auto"></spinmodel> </div>',
        scope: {
          model: '=model',
          edit: '=edit',
          ondelete: '=ondelete',
          hideproperties: '='
        },
        link: function(scope, elem, attrs) {},
        controller: function($scope) {
          console.log('spinwalker model originally is');
          console.dir($scope.model);
          if (typeof $scope.replace === 'undefined') {
            $scope.replace = true;
          }
          $scope.selectedmodel = $scope.model;
          $scope.breadcrumbs = [$scope.model];
          $scope.$watch('model', function(newval, oldval) {
            console.log('spinwalker model = ' + $scope.model);
            console.log('newval is..');
            console.dir(newval);
            console.log('oldval is');
            console.dir(oldval);
            if (oldval !== newval) {
              if ($scope.model) {
                if (!$scope.breadcrumbs) {
                  console.log('************************************************* creating new breadcrumbs...');
                  $scope.breadcrumbs = [$scope.model];
                }
                $scope.selectedmodel = $scope.model;
              }
              return $scope.onselect($scope.model, $scope.replace);
            }
          });
          $scope.crumbClicked = function(model) {
            var crumb, i, idx, j, len, ref;
            $scope.selectedmodel = model;
            idx = -1;
            ref = $scope.breadcrumbs;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              crumb = ref[i];
              console.log('--- ' + ' crumb ' + crumb.name + ', id ' + crumb.id);
              if (crumb.id === model.id) {
                idx = i;
              }
            }
            idx++;
            if (idx > -1 && $scope.breadcrumbs.length > idx) {
              return $scope.breadcrumbs = $scope.breadcrumbs.slice(0, idx);
            }
          };
          $scope.onselect = function(model, replace) {
            console.log('spinwalker.onselect model ' + model + ' replace ' + replace);
            if (replace) {
              $scope.breadcrumbs = [];
            }
            $scope.selectedmodel = model;
            console.log('pushing..');
            return $scope.breadcrumbs.push(model);
          };
          return $scope.crumbPresentation = function(crumb) {
            return crumb.name || crumb.type;
          };
        }
      };
    }
  ]).directive('spinlistmodel', [
    'spinclient', function(client) {
      return {
        restrict: 'AE',
        replace: true,
        template: '<div > <spinlist listmodel="listmodel" list="list" onselect="onourselect" replace="replace" ondelete="onourdelete" edit="edit" search="search" searchfunc="searchfunc"></spinlist> </div>',
        scope: {
          listmodel: '=listmodel',
          edit: '=edit',
          onselect: '&',
          ondelete: '&'
        },
        link: function(scope, elem, attrs) {
          scope.onselect = scope.onselect();
          return scope.ondelete = scope.ondelete();
        },
        controller: function($scope) {
          $scope.onourselect = function(item) {
            console.log('spinlistmodel our select called. provided select is ' + $scope.onselect);
            if ($scope.onselect) {
              return $scope.onselect(item);
            }
          };
          $scope.onourdelete = function(item) {
            console.log('spinlistmodel delete called');
            if ($scope.ondelete) {
              return $scope.ondelete(item);
            } else {
              return client.emitMessage({
                target: '_delete' + item.type,
                obj: {
                  id: item.id,
                  type: item.type
                }
              }).then((function(_this) {
                return function(o) {
                  return console.log('deleted ' + o.type + ' on server');
                };
              })(this));
            }
          };
          $scope.search = 'server';
          console.log('*** spinlistmodel created, type is ' + $scope.listmodel + ', search is ' + $scope.search);
          client.emitMessage({
            target: '_list' + $scope.listmodel + 's'
          }).then(function(newlist2) {
            var tmp;
            tmp = [];
            newlist2.forEach(function(item) {
              return tmp.push(item.id);
            });
            console.log('spinlistmodel list is now ' + tmp);
            return $scope.list = tmp;
          });
          return $scope.searchfunc = function(v, qprop, qval, selectedindex) {
            var q;
            console.log('spinlistmodel - searchfunc');
            console.dir(arguments);
            if (v) {
              if (qprop === 'id') {
                q = {
                  property: qprop,
                  value: v || ''
                };
              } else {
                q = {
                  property: qprop,
                  value: v || '',
                  limit: 10,
                  skip: 10 * selectedindex,
                  wildcard: !!v
                };
              }
              console.log('---- query sent to server is..');
              console.dir(q);
              return client.emitMessage({
                target: '_list' + $scope.listmodel + 's',
                query: q
              }).then(function(newlist) {
                var tmp;
                console.log('search got back list of ' + newlist.length + ' items');
                tmp = [];
                newlist.forEach(function(item) {
                  return tmp.push(item.id);
                });
                return $scope.list = tmp;
              });
            } else {
              return client.emitMessage({
                target: '_list' + $scope.listmodel + 's'
              }).then(function(newlist2) {
                var tmp;
                tmp = [];
                newlist2.forEach(function(item) {
                  return tmp.push(item.id);
                });
                return $scope.list = tmp;
              });
            }
          };
        }
      };
    }
  ]).directive('spinlist', [
    'spinclient', function(client) {
      return {
        restrict: 'AE',
        replace: false,
        template: '<div > <md-subheader class="md-no-sticky" style="background-color:#ddd"> <md-icon md-svg-src="assets/images/ic_apps_24px.svg" ></md-icon> List of {{listmodel}}s</md-subheader> <div ng-if="list" layout="row" > <md-input-container flex style="padding:0"> <label>Property:</label> <md-select aria-label="search property" ng-model="qproperty" placeholder="name" ng-change="onsearchchange(qproperty)" > <md-option ng-value="opt" ng-repeat="opt in objectmodel" value="{{opt.name}}">{{ opt.name }}</md-option> </md-select> </md-input-container> <md-input-container flex layout-align="center" style="padding:0"> <label>Search:</label> <input aria-label="search value" type="text" ng-model="qvalue" required ng-change="onvaluechanged(qvalue)"> </md-input-container> </div> <md-list flex> <md-list-item ng-repeat="item in expandedlist track by item.id" layout="row" style="min-height:10px"> <md-button ng-if="edit" aria-label="delete" class="md-icon-button" ng-click="deleteItem(item)"> <md-icon md-svg-src="assets/images/ic_delete_24px.svg"></md-icon> </md-button> <md-button  ng-click="selectItem(item)"> <img ng-if="item.value" ng-src="item.value"> {{ objects[item.id].name }} </md-button> </md-list-item> </md-list> <div ng-if="listcount.length>0" style="padding:15px"> <span ng-style="setIndexStyle($index)" ng-click="selectPage($index)" ng-repeat="n in listcount track by $index"> {{$index}}</span> </div> </div>',
        scope: {
          list: '=list',
          listmodel: '=listmodel',
          edit: '=edit',
          search: '=search',
          onselect: '&',
          ondelete: '&',
          searchfunc: '&'
        },
        link: function(scope, elem, attrs) {
          scope.onselect = scope.onselect();
          scope.ondelete = scope.ondelete();
          return scope.searchfunc = scope.searchfunc();
        },
        controller: function($scope) {
          var failure, success;
          $scope.search = $scope.search || 'local';
          $scope.list = $scope.list || [];
          $scope.subscriptions = [];
          $scope.expandedlist = [];
          $scope.objects = client.objects;
          $scope.objectmodel = [];
          $scope.selectedindex = 0;
          $scope.listcount = [];
          $scope.qvalue = '';
          $scope.qproperty = 'name';
          $scope.origlist = $scope.list;
          client.getModelFor($scope.listmodel).then(function(md) {
            $scope.objectmodel = md;
            return $scope.objectmodel.push({
              name: 'id',
              "public": true,
              value: 'id'
            });
          });
          success = (function(_this) {
            return function(result) {
              return console.log('success: ' + result);
            };
          })(this);
          failure = (function(_this) {
            return function(err) {
              console.log('error: ' + err);
              return console.dir(err);
            };
          })(this);
          $scope.setIndexStyle = function(i) {
            var rv;
            if (i !== $scope.selectedindex) {
              rv = {
                color: "black",
                "background-color": "white",
                padding: "20px"
              };
            } else {
              rv = {
                color: "white",
                "background-color": "black",
                padding: "20px"
              };
            }
            return rv;
          };
          $scope.selectPage = function(p) {
            console.log('********************************************************* page ' + p + ' selected');
            $scope.selectedindex = p;

            /*q = {property: $scope.qproperty, value: $scope.qvalue or '', limit:10, skip: 10*p, wildcard: !!$scope.qvalue}
            client.emitMessage({ target:'_list'+$scope.listmodel+'s', query: q}).then( (newlist) ->
              console.log 'paged search got back list of '+newlist.length+' items'
              tmp = []
              newlist.forEach (item)-> tmp.push item.id
              $scope.list = tmp
              $scope.renderList())
             */
            return $scope.renderList();
          };
          $scope.onsearchchange = function(v) {
            console.log('* onsearchchange called. v = ' + v + ' qprop = ' + $scope.qproperty + ', qval = ' + $scope.qvalue);
            if ($scope.search !== 'local') {
              return $scope.doSearch($scope.qproperty, v);
            } else {
              return $scope.localSearch(v);
            }
          };
          $scope.onvaluechanged = function(v) {
            if ($scope.search !== 'local') {
              return $scope.doSearch($scope.qproperty, v);
            } else {
              return $scope.localSearch(v);
            }
          };
          $scope.doSearch = function(prop, v) {
            if ($scope.searchfunc) {
              return $scope.searchfunc(v, prop, $scope.qvalue, $scope.selectedindex);
            } else {
              return console.log('no searchfunc defined');
            }
          };
          $scope.localSearch = function(v) {
            var tmp;
            tmp = [];
            $scope.origlist.forEach(function(id) {
              var item;
              item = client.objects[id];
              if (v) {
                if (("" + item[$scope.qproperty]).indexOf(v) > -1) {
                  return tmp.push(item.id);
                }
              } else {
                return tmp.push(item.id);
              }
            });
            $scope.list = tmp;
            return $scope.renderList();
          };
          $scope.selectItem = (function(_this) {
            return function(item) {
              console.log('item ' + item.name + ' selected');
              if ($scope.onselect) {
                return $scope.onselect(item, $scope.replace);
              }
            };
          })(this);
          $scope.deleteItem = function(item) {
            console.log('list item delete clicked. $scope.ondelete = ' + $scope.ondelete);
            if ($scope.ondelete) {
              return $scope.ondelete(item);
            }
          };
          $scope.$watch('list', function(newval, oldval) {
            return $scope.renderList();
          });
          $scope.renderPageSelector = function() {
            var count, ref;
            count = $scope.list.length;
            if (count < 50) {
              $scope.listcount.length = 1;
            } else {
              $scope.listcount.length = parseInt(count / 50) + ((ref = (count % 25) > 0) != null ? ref : {
                1: 0
              });
            }
            $scope.totalcount = count;
            return console.dir($scope.expandedlist);
          };
          $scope.renderList = function() {
            var base, i, id, j, l, len, modelid, ref, ref1, results1, slice, x;
            $scope.renderPageSelector();
            $scope.expandedlist = [];
            base = $scope.selectedindex * 50;
            console.log('renderList - listcount = ' + $scope.listcount.length + ', base = ' + base);
            slice = $scope.list;
            if ($scope.list.length > 50) {
              slice = [];
              for (x = j = ref = base, ref1 = base + 50; ref <= ref1 ? j <= ref1 : j >= ref1; x = ref <= ref1 ? ++j : --j) {
                id = $scope.list[x];
                console.log('adding slice ' + id);
                slice.push(id);
              }
            }
            results1 = [];
            for (i = l = 0, len = slice.length; l < len; i = ++l) {
              modelid = slice[i];
              console.log('**spinlist expanding list reference for model id ' + modelid + ' of type ' + $scope.listmodel);
              if (client.objects[modelid]) {
                console.log('found model ' + i + ' in cache ' + modelid);
                console.dir(client.objects[modelid]);
                results1.push($scope.addExpandedModel(client.objects[modelid], slice));
              } else {
                if (modelid) {
                  console.log('fetching model ' + i + ' from server ' + modelid);
                  results1.push(client.emitMessage({
                    target: '_get' + $scope.listmodel,
                    obj: {
                      id: modelid,
                      type: $scope.listmodel
                    }
                  }).then(function(o) {
                    client.objects[o.id] = o;
                    console.log('got back from server ' + o.id + ' -> ' + o);
                    return $scope.addExpandedModel(o, slice);
                  }, failure));
                } else {

                }
              }
            }
            return results1;
          };
          $scope.addExpandedModel = function(o, list) {
            var i, j, len, modid, results1;
            results1 = [];
            for (i = j = 0, len = list.length; j < len; i = ++j) {
              modid = list[i];
              if (modid === o.id) {
                results1.push($scope.expandedlist[i] = o);
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          };
          $scope.onSubscribedObject = function(o) {
            var added, i, j, k, len, mod, model, ref, v;
            added = false;
            ref = $scope.list;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              model = ref[i];
              if (model.id === o.id) {
                mod = $scope.expandedlist[i];
                for (k in o) {
                  v = o[k];
                  added = true;
                  mod[k] = v;
                }
              }
            }
            if (!added) {
              $scope.expandedlist.push(o);
            }
            $scope.expandedlist.sort(function(a, b) {
              if (a.name === b.name) {
                return 0;
              } else if (a.name > b.name) {
                return 1;
              } else {
                return -1;
              }
            });
            return $scope.$apply();
          };
          $scope.list.forEach(function(id) {
            if (id) {
              return client.registerObjectSubscriber({
                id: id,
                type: $scope.listmodel,
                cb: $scope.onSubscribedObject
              }).then(function(listenerid) {
                return $scope.subscriptions.push({
                  sid: listenerid,
                  o: {
                    type: $scope.listmodel,
                    id: id
                  }
                });
              });
            }
          });
          return $scope.$on('$destroy', (function(_this) {
            return function() {
              console.log('spinlist captured $destroy event');
              return $scope.subscriptions.forEach(function(s) {
                return client.deRegisterObjectSubscriber(s.sid, s.o);
              });
            };
          })(this));
        }
      };
    }
  ]).directive('spinhash', [
    'spinclient', function(client) {
      return {
        restrict: 'AE',
        replace: false,
        template: '<div> <md-subheader class="md-no-sticky" style="background-color:#ddd"> <md-icon md-svg-src="assets/images/ic_apps_24px.svg" ></md-icon> Hash of {{listmodel}}s</md-subheader> <md-list> <md-list-item ng-repeat="item in expandedlist" layout="row"> <md-button ng-if="!edit" aria-label="delete" class="md-icon-button" ng-click="deleteItem(item)"> <md-icon md-svg-src="bower_components/material-design-icons/action/svg/production/ic_delete_24px.svg"></md-icon> </md-button> <md-button  ng-click="selectItem(item)">{{ objects[item.id].name }}</md-button> </md-list> </div>',
        scope: {
          list: '=list',
          listmodel: '=listmodel',
          onselect: '&',
          ondelete: '&'
        },
        link: function(scope, elem, attrs) {
          scope.onselect = scope.onselect();
          return scope.objects = client.objects;
        },
        controller: function($scope) {
          var failure, j, len, mid, ref;
          console.log('spinhash list for model ' + $scope.listmodel + ' is a ' + (typeof $scope.list));
          console.dir($scope.list);
          if (typeof $scope.list === 'string') {
            $scope.list = eval($scope.list);
          }
          console.dir($scope.list);
          $scope.objects = client.objects;
          $scope.expandedlist = [];
          failure = (function(_this) {
            return function(err) {
              console.log('error: ' + err);
              return console.dir(err);
            };
          })(this);
          ref = $scope.list;
          for (j = 0, len = ref.length; j < len; j++) {
            mid = ref[j];
            client.emitMessage({
              target: '_get' + $scope.listmodel,
              obj: {
                id: mid,
                type: $scope.listmodel
              }
            }).then(function(o) {
              var i, l, len1, modid, ref1, results1;
              ref1 = $scope.list;
              results1 = [];
              for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
                modid = ref1[i];
                if (modid === o.id) {
                  console.log('adding hashtable element ' + o.name);
                  client.objects[o.id] = o;
                  results1.push($scope.expandedlist.push(o));
                } else {
                  results1.push(void 0);
                }
              }
              return results1;
            }, failure);
          }
          return $scope.selectItem = (function(_this) {
            return function(item) {
              if ($scope.onselect) {
                return $scope.onselect(item, $scope.replace);
              }
            };
          })(this);
        }
      };
    }
  ]).directive('spingrid', [
    'spinclient', '$mdDialog', function(client, $mdDialog) {
      return {
        restrict: 'AE',
        replace: false,
        template: '<div> <md-subheader class="md-no-sticky" style="background-color:#ddd"> <md-icon md-svg-src="assets/images/ic_apps_24px.svg" ></md-icon> Grid of {{listmodel}}s</md-subheader> <md-grid-list md-cols="{{ocols}}" md-row-height="35px" style="margin-right:16px"> <md-grid-tile ng-repeat="prop in objectmodel" style="background-color: #cacaca"> {{prop.name}} </md-grid-tile> <md-grid-tile ng-repeat="cell in cells" style="height:15px" layout-fill> <md-button raised ng-if="onselect" ng-click="selectItem(cell.item)">Select</md-button> <span flex ng-if="cell.prop.type && cell.prop.value && !cell.prop.hashtable && !cell.prop.array" ng-click="enterDirectReference(prop)">{{cell.item[cell.prop.name]}}</span> <input layout-fill flex ng-if="!cell.prop.array && !cell.prop.type &&  isEditable(cell.prop.name) && cell.prop.name != \'id\'" type="text" ng-model="cell.item[cell.prop.name]" ng-change="onChange(cell.item, cell.prop.name)"> <input layout-fill flex ng-if="!cell.prop.array && !cell.prop.type && !isEditable(cell.prop.name) && cell.prop.name != \'id\'" type="text" ng-model="cell.item[cell.prop.name]" disabled="true"> <span flex ng-if="isEditable(cell.prop.name) && (cell.prop.array || cell.prop.hashtable)" ng-model="cell.item[cell.prop.name]" ng-click="selectModel(cell.item, cell.prop.type, cell.prop.name)">{{cell.item[cell.prop.name].length}} {{cell.prop.name}}</span> <span flex ng-if="!isEditable(cell.prop.name) && (cell.prop.array || cell.prop.hashtable)" >{{cell.item[cell.prop.name].length}} {{cell.prop.name}}</span> </md-grid-tile> </md-grid-list> </div>',
        scope: {
          list: '=list',
          listmodel: '=listmodel',
          onselect: '&',
          ondelete: '&',
          edit: '=edit'
        },
        link: function(scope, elem, attrs) {
          return scope.onselect = scope.onselect();
        },
        controller: function($scope) {
          var failure, success;
          console.log('spingrid list for model ' + $scope.listmodel + ' is');
          console.dir($scope.list);
          $scope.objects = client.objects;
          $scope.expandedlist = [];
          $scope.objectmodel = [];
          $scope.ocols = 4;
          $scope.cells = [];
          $scope.nonEditable = ['createdAt', 'createdBy', 'modifiedAt'];
          $scope.isEditable = (function(_this) {
            return function(propname) {
              var rv;
              rv = $scope.edit;
              if (!propname) {
                rv = false;
              }
              if (indexOf.call($scope.nonEditable, propname) >= 0) {
                rv = false;
              }
              return rv;
            };
          })(this);
          client.getModelFor($scope.listmodel).then(function(md) {
            var j, len, mid, ref, results1;
            $scope.objectmodel = md;
            $scope.objectmodel.push({
              name: 'id',
              "public": true,
              value: 'id'
            });
            $scope.ocols = md.length;
            ref = $scope.list;
            results1 = [];
            for (j = 0, len = ref.length; j < len; j++) {
              mid = ref[j];
              results1.push(client.emitMessage({
                target: '_get' + $scope.listmodel,
                obj: {
                  id: mid,
                  type: $scope.listmodel
                }
              }).then(function(o) {
                var i, k, l, len1, modid, ref1, results2, v;
                ref1 = $scope.list;
                results2 = [];
                for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
                  modid = ref1[i];
                  if (modid === o.id) {
                    console.log('adding hashtable element ' + o.name);
                    $scope.expandedlist[i] = o;
                    client.objects[o.id] = o;
                    results2.push((function() {
                      var ref2, results3;
                      ref2 = $scope.objectmodel;
                      results3 = [];
                      for (k in ref2) {
                        v = ref2[k];
                        results3.push($scope.cells.push({
                          item: o,
                          prop: v
                        }));
                      }
                      return results3;
                    })());
                  } else {
                    results2.push(void 0);
                  }
                }
                return results2;
              }, failure));
            }
            return results1;
          });
          failure = (function(_this) {
            return function(err) {
              console.log('error: ' + err);
              return console.dir(err);
            };
          })(this);
          success = (function(_this) {
            return function(result) {
              return console.log('success: ' + result);
            };
          })(this);
          $scope.selectItem = (function(_this) {
            return function(item) {
              var deepclone;
              console.log('spingrid selected item ' + item);
              console.dir(item);
              deepclone = JSON.parse(JSON.stringify(item));
              if ($scope.onselect) {
                return $scope.onselect(deepclone, $scope.replace);
              }
            };
          })(this);
          $scope.onChange = (function(_this) {
            return function(model) {
              console.log('spingrid onChange called for');
              console.dir(model);
              $scope.activeField = model.type;
              return client.emitMessage({
                target: 'updateObject',
                obj: model
              }).then(success, failure);
            };
          })(this);
          return $scope.selectModel = function(item, type, propname) {
            var objlist;
            console.log('selectModel called for prop ' + propname + ' type ' + type);
            objlist = item[propname];
            return $mdDialog.show({
              controller: function(scope) {
                var list;
                console.log('++++++++++++++ spingrid selectModel controller type=' + type + ', propname=' + propname + ' objlist is...');
                console.dir(objlist);
                list = [];
                objlist.forEach(function(id) {
                  return list.push(id);
                });
                scope.list = list;
                scope.type = type;
                scope.item = item;
                scope.propname = propname;
                scope.addModel = function(item, type, propname) {
                  console.log('spingrid.addModel called for type ' + type + ' propname ' + propname);
                  console.dir(item);
                  return client.emitMessage({
                    target: '_create' + type,
                    obj: {
                      name: 'new ' + type,
                      type: type
                    }
                  }).then((function(_this) {
                    return function(o) {
                      item[propname].push(o.id);
                      console.log('update list after addition');
                      console.dir(item[propname]);
                      scope.list = item[propname];
                      return client.emitMessage({
                        target: 'updateObject',
                        obj: item
                      }).then(success, failure);
                    };
                  })(this), failure);
                };
                scope.ondelete = function(arrayitem) {
                  return client.getModelFor(item.type).then(function(md) {
                    var i, idx, j, len, li, mid;
                    propname = void 0;
                    console.log('item');
                    console.dir(item);
                    md.forEach(function(m) {
                      if (m.type === arrayitem.type) {
                        return propname = m.name;
                      }
                    });
                    li = item[propname];
                    console.log('li');
                    console.dir(li);
                    idx = -1;
                    for (i = j = 0, len = li.length; j < len; i = ++j) {
                      mid = li[i];
                      if (mid === arrayitem.id) {
                        idx = i;
                      }
                    }
                    if (idx > -1) {
                      li.splice(idx, 1);
                    }
                    item[propname] = li;
                    scope.list = item[propname];
                    return client.emitMessage({
                      target: 'updateObject',
                      obj: item
                    }).then(function() {
                      console.log('update list after deletion');
                      return console.dir(li);
                    });
                  });
                };
                console.log('list is');
                console.dir(list);
                scope.hide = function() {
                  console.log('hiding dialog');
                  return $mdDialog.hide();
                };
                return scope.onselect = function(model) {
                  var exists, id, j, len, ref;
                  console.log('* spingrid selectMode onselect callback');
                  console.dir(model);
                  exists = false;
                  console.log('-- checking for dupes --');
                  console.dir(item[propname]);
                  ref = item[propname];
                  for (j = 0, len = ref.length; j < len; j++) {
                    id = ref[j];
                    console.log('testing if existing list model ' + id + ' matches new addition ' + model.id);
                    if (id === model.id) {
                      exists = true;
                    }
                  }
                  if (!exists) {
                    console.log('-- adding new model to list');
                    item[propname].push(model.id);
                    scope.list = item[propname];
                    client.emitMessage({
                      target: 'updateObject',
                      obj: item
                    }).then(success, failure);
                  } else {
                    console.log('avoiding adding duplicate!');
                  }
                  return $mdDialog.hide();
                };
              },
              template: '<md-dialog aria-label="selectdialog"> <md-dialog-content style="width:300px;margin:10px"> <md-button class="md-raised" ng-click="addModel(item, type, propname)">New {{type}}</md-button> <md-button class="md-raised" ng-click="hide()">Close</md-button> <spinlist listmodel="type" list="list" edit="true" onselect="onselect" ondelete="ondelete"></spinlist> </md-dialog-content> </md-dialog>'
            });
          };
        }
      };
    }
  ]);

}).call(this);

//# sourceMappingURL=spinclient.js.map
